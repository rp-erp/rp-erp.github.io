{"/development-guide":{"title":"Overview","data":{}},"/development-guide/tooling-service-development":{"title":"Tooling Services Development","data":{"table-of-contents#Table of Contents":"External Communication\nCommunication without Tooling Service\nCommunication via Tooling Services\nSynchronous Communication via RESTful API\nAsynchronous Communication via Message Queue\nInternal Communication\nDevelopment Guide\nHow to implement a Service Provider\nHow to implement Restful API\nHow to implement Queue Processor\nHow to implement Cron Queue\nThis document illustrates the external and internal communication of Tooling Service.","external-communication#External Communication":"","communication-without-tooling-service#Communication without Tooling Service":"The following diagram decribes how our ERP System works together without Tooling Service.As can be seen that all clients such as Mobile App, ERP Web or other API Clients like Postman interact with our system through Main Services (Service Gate) and receive the response in synchronous communication way. This synchronous communication approach has an advantage, allowing clients to retrieve the result from the server in realtime. However, it also has a downside that if the Main Services are trying to process a heavy task, it can delay the clients receiving the output and causes a poor UX experience.","communication-via-tooling-services#Communication via Tooling Services":"In order to resolve the delayed issue when communicating synchronously, Tooling Service jumps into the play.According to the diagram, the clients now interacting with the ERP System via RESTful API endpoint that exposes from Tooling Services. In general, Tooling Services supports two way of communication\nSynchronous via RESTful API.\nAsynchronous via Message Queue that facilitates the Pub-Sub pattern","synchronous-communication-via-restful-api#Synchronous Communication via RESTful API":"There're two use cases of synchronous communication via RESTful API\nSending a message to a message queue via Publisher.\nCalling Main Services API for some business customization: This approach is used when you want to customize the request before sending to our main services or doing some pre-calculation before hand. Basically, this way keeps the implementation in Main Service reusable internally and avoid Anti-IF pattern.\nFor example, Converting Image to Pdf is not a responsibility of Main Services. Therefore, you can develop this feature in Tooling Services and exposes via RESTful API.Another example for Caching, you want to cache the response from the Main Services for the next query. You can use Tooling Service as a Reversed Proxy, forward the client request to main service and cache the response into caching database that Tooling Services is integrating with. With this use case, The performance of our system will be significantly improved.","asynchronous-commnication-via-message-queue#Asynchronous Commnication via Message Queue":"Just want to emphasize that this process happens after the Publisher and Cron add new message into the Message Queue. Then, Subcribers will perform the business logic and returns the response in background. In addition, you can monitor the process and result by using Bull Board at http://127.0.0.1/admin/queues.When it comes to the implementation in Subcriber component, it can be developed indenpendently or dependent on Main Services to serve some heavy business task purposes.For example, The PO Signature use case, just consider the CEO is busy all the time so he wants to sign all **Purchase Order Approval **in the fastest way, so the mobile should not wait the server to validate the signature, mark the approval and upload the document to the cloud. Consequently, we should response our CEO the status as approval is processing immediately and allows him to sign the next one. For the unprocessed server tasks, we can delegate them to a queue and execute them later on.","internal-communication#Internal Communication":"There're four main components in Tooling Services project\nshared: To store all common use lib that share with among components in this project\nservice: To store all main or business logic of a service that will be used in api or queue\napi: To store the implementation that exposes the gateway to the clients via the RESTful API endpoints\nqueue: To store the implementation that will work in the background. It will be triggered by api or by itself via cron.\nPlease see the diagram below for more detailsIn general, you can understand the internal communication like following:\nAll components can use all modules in shared.\napi and queue must use service for the business implementation.","development-guide#Development Guide":"","how-to-implement-a-service-provider#How to implement a Service Provider":"Updating...","how-to-implement-restful-api#How to implement Restful API":"Step 1: Create a new folder for new Restful API\nStep 2: Create a controller file.\nStep 3: Create module file and import the created controller at step 2.\nStep 4: Create DTO (Data Transfer Object) file then add @ApiProperty decorator for the attributes.\nStep 5: Import the created module at step 3 into src/api/api-manager.module.ts file.\nFor example: I want to create a new Restful API for Document Export. Below are the files and folder I will create in src/api.\n  //Endpoint: POST /api/export-document/po-signed-document/:extension\n  import { Controller, HttpCode, Post, Req } from '@nestjs/common';\n  import { ApiBody, ApiResponse, ApiTags } from '@nestjs/swagger';\n  import { GenericRequestBodyDTO } from '../generic-request-body.dto';\n  @ApiTags('Export Document')\n  @Controller('api/export-document')\n  export class ExportDocumentApiController {\n    @Post('po-signed-document/:extension')\n    @ApiResponse({ status: 200, description: 'Successfully' })\n    @ApiBody({ type: GenericRequestBodyDTO })\n    @HttpCode(200)\n    async exportPOSignedDocument(@Req() req) {\n      return { message: `PO Signed Document  has been put in queue successfully` };\n    }\n  }\nimport { Module } from '@nestjs/common';\nimport { ExportDocumentApiController } from './export-document-api.controller';\n@Module({\n  imports: [],\n  controllers: [ExportDocumentApiController]\n})\nexport class ExportDocumentApiModule { }\n  import { Module } from '@nestjs/common';\n  import { ConvertApiModule } from './convert-api/convert-api.module';\n  import { ExportDocumentApiModule } from './export-document-api/export-document-api.module';\n  @Module({\n    imports: [\n      ConvertApiModule,\n      ExportDocumentApiModule\n    ],\n  })\n  export class ApiManagerModule { }","how-to-implement-queue-processor#How to implement Queue Processor":"Updating..."}},"/howto/create-ssl-for-viettel-cloud":{"title":"Create SSL for Viettel Cloud","data":{"":"Create new account at ZeroSSL . With new account will be Free 3 months\nIn Dashboard, click New Certificate (Image 1)\nEnter required information (Domains: 27.71.232.40; Validity: 90-Day Certificate; Finalize Your Order: Free) => click Next Step\nVerification Method for 27.71.232.40 choose HTTP File Upload and Download Auth File. After download complete, click Next Step  (Image 2)\n5.Add file downloaded to Viettel cloud IIS  with URL in Image 2\n6. Click Verify Domain (Image 3)\nDownload Certificate as zip file (Image 4) and click Next Step\nExtract zip file on Viettel Server, open Start Menu, type openssl, open program and browse to extracted folder (Image 5)\nCopy content file create file pfx.txt and run in Open SSL cmd (Image 6)\nEnter password, this password use to import certificate into IIS (ex: robinsonpharma), after done, we have certificate.pfx file in extracted folder (Image 7)\nOpen IIS Manager → Server Certificates → Remove old certificate (if any) → Click Import (Image 8)\nUse pfx file create before and password enter at step 10 → click OK (Image 9)\nIn IIS choose each Website and update binding to new certificate (Image 10)"}},"/howto/how-to-install-redis-on-window-server":{"title":"How to install Redis on Windows Server","data":{"":"This article shows the instruction on how to install Redis server on Window Server.Overall, there are two main parts of the installation\nInstall Subsystem Ubuntu\nInstall Redis Stack Server","1-install-subsystem-ubuntu#1. Install Subsystem Ubuntu":"Redis from the 7.x.x version does not support on native window anymore. So we need to install linux subsystem and install Redis on top of it.To begin with, please open POWER SHELL and follow the steps below.Step 1: Download Ubuntu and enable Linux Subsystem mode on Windows (You should not run Ubuntu 20.04 LTS version because there are some recorded issues that have not been fixed on the official MS website, so we will use Ubuntu 18.04 LTS version)\nInvoke-WebRequest -Uri https://aka.ms/wsl-ubuntu-1804 -OutFile Ubuntu.zip -UseBasicParsing\nStep 2: Unzip the Ubuntu file downloaded in the step #1\nExpand-Archive ./Ubuntu.zip ./Ubuntu\nStep 3: Set environment variables\n$userenv = [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\")\n[System.Environment]::SetEnvironmentVariable(\"PATH\", $userenv + $(Get-Location).Path + \"\\Ubuntu\", \"User\")\nStep 4: Install WSL, Enter \"Y\" to restart the machine.\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux\nStep 5: Change directory to Ubuntu folder and execute ubuntu1804.exe file\ncd Ubuntu\n.\\ubuntu1804.exe\nStep 6: Set up your root user. Note: it should be your window machine username. In sta\nsudo passwd <your_window_user>\nNew password: <pass_word>\nRetype new password: <pass_word>\nStep 7\nsu <your_window_user>\n<Enter the password>\nStep 8: Update package repository\nsudo apt-get update\nsudo apt-get upgrade","2-install-redis-stack-server#2. Install Redis Stack Server":"First, access to linux terminal\nwsl\nThen, follow the steps below.Step 1\ncurl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg\nStep 2\nsudo chmod 644 /usr/share/keyrings/redis-archive-keyring.gpg\nStep 3\nsudo apt-get update\nStep 4\necho \"deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/redis.list\nStep 5\nsudo apt-get install redis-stack-server\nStep 6\nmkdir redis_db_data\nStep 6: Create redis.conf at the same folder level with this contentNote: put your redis password on <redis_password>\nbind 0.0.0.0\nport 6380\nrequirepass <redis_password>\nsave 60 1000\nappendonly yes\ndir /redis_db_data\nstop-writes-on-bgsave-error no\nStep 7: Create start.sh file\nsudo redis-stack-server ./redis.conf --daemonize yes\nyou might get this warning\n WARNING Memory overcommit must be enabled! Without it, a background save or replication may fail under low memory condition. Being disabled, it can also cause failures without low memory condition, see https://github.com/jemalloc/jemalloc/issues/1328. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\nTo fix it, execute this command\nsudo vim  /etc/sysctl.conf\nThen, press i to switch to INSERT MODE and add this content\nvm.overcommit_memory=1\nNext, press ESC button then type :wq and ENTER to save the content.\nFinally, execute this command to load the config\nsudo sysctl vm.overcommit_memory=1\nThen restart redis server.Step 8: Create stop.sh file\nredis-cli -h 127.0.0.1 -p 6380 -a <redis_password> shutdown nosave\nStep 9: Start Redis Stack Server\nwsl\nsudo bash ./start.sh\nNote: to stop server, just execute bash .\\stop.shStep 10: Allow Redis port to external app (optional)open POWER SHELL and execute the command below\nNew-NetFirewallRule -DisplayName \"Allow Redis Port 6380\" -Direction Inbound -LocalPort 6380 -Protocol TCP -Action Allow"}},"/howto/install-ssh-server-on-window":{"title":"How to Install SSH Server on Windows","data":{"install-ssh-server#Install SSH Server":"To set up SSH access to your Windows server, you can use the built-in OpenSSH Server. Here's a step-by-step guide:\nInstall OpenSSH Server: Open PowerShell as Administrator and run the following command:\nAdd-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0\nStart the service: Once installed, start the SSH server service by running:\nStart-Service sshd\nSet the service to start automatically: To ensure the SSH server is automatically started after a reboot, run:\nSet-Service -Name sshd -StartupType 'Automatic'\nConfirm the Firewall rule is configured: It should be created automatically by the setup. In case it's not, run:\nNew-NetFirewallRule -Name sshd -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22\nCheck the installation: You can check that the installation was successful by running:\nGet-WindowsCapability -Online | ? Name -like 'OpenSSH*'\nCreate an SSH key pair: On your local machine, use ssh-keygen to create an SSH key pair. If you're on Linux or macOS, you can use the following command:\nssh-keygen\nSet permission\ncd ~\nmkdir .ssh\nnotepad.exe .ssh\\authorized_keys\nAdd content for authorized_keys file\nicacls .ssh /inheritance:r\nicacls .ssh /grant \"your-username:(F)\"\nicacls .ssh\\authorized_keys /inheritance:r\nicacls .ssh\\authorized_keys /grant \"your-username:(F)\"\nOpen config file at C:\\\\ProgramData\\ssh\\sshd_config and remove the # at the beginning of the line to uncomment it, and change 22 to your desired port number. For example, to change the SSH port to 2422\nPort 2422\nOpen Port 2422\nNew-NetFirewallRule -DisplayName \"Open Port 2422\" -Direction Inbound -LocalPort 2422 -Protocol TCP -Action Allow\nRestart SSH server to take effect\nRestart-Service sshd\nGet-Service sshd","setup-ssh-user#Setup SSH User":"Create a new user\nYou can create a new user with the following command in PowerShell, replacing username and password with the username and password you want to use\nNew-LocalUser -Name \"username\" -Password (ConvertTo-SecureString -AsPlainText \"password\" -Force)\nAdd a user to the Administrators group\nTo add a user to the Administrators group on a Windows Server using PowerShell, you can use the Add-LocalGroupMember cmdlet. Here's how you can do it\nAdd-LocalGroupMember -Group \"Administrators\" -Member \"username\"\nAllow the user to log in through SSH\nBy default, only users in the Administrators group can log in through SSH. If the user is not in the Administrators group, you'll need to add them to the sshd_config file. You can do this by opening the file (usually located at C:\\ProgramData\\ssh\\sshd_config) in a text editor and adding the following line, replacing username with the username you used in the previous steps:\nAllowUsers username\nAfter making these changes, you'll need to restart the OpenSSH Server service for the changes to take effect. You can do this with the following command in PowerShell\nRestart-Service sshd\nThe end"}},"/":{"title":"RP-ERP Knowledge Base","data":{"":"Welcome to the RP-ERP Knowledge Base, your one-stop destination for mastering both technical intricacies and business processes in the world of Enterprise Resource Planning. Dive into a curated collection of technical documentation for seamless integration, and explore strategic insights to elevate your understanding of RP-ERP's impact on operational efficiency. Whether you're a tech enthusiast or a business leader, find the expertise you need to excel in resource planning and enterprise excellence."}},"/process/release-management":{"title":"Git Strategies & Release Management","data":{"overview#Overview":"The release cycle has 5 phases\nPhase 1: Start new release\nPhase 2: Develop\nPhase 3: Release\nPhase 4: Hotfix release (Optional)\nPhase 5: Close the release","branches#Branches":"","default-branch#Default branch":"All branches have suffix Test in name are default branches: RPGlobal-Test, RPServiceGate-Test, RPWebMVC-Test, AppTest\nTest branches have the latest commits including New features, Bugfixes and Hotfixes\nTest branches are the base branches of Developers on their daily work. It means that all commits MUST BE merged into Test branches first.","release-branch#Release branch":"Release branch is created at Phase 1: Start new release and based on Test branch.\nRelease branch's name has the following convention Release-<YYYYMMDD>. For example, the release name Release-20231121 indicating that all commits in this branch are releasing on 21 November, 2023\nAll commits are ready to push into Release branch must come from Test branch and pushed by using cherry-pick instead of merge","deploy-branches#Deploy branches":"Deploy branches will be used for CI/CD pipeline in the future\nThere're 2 deploy branches: deploy/erptest and deploy/production\ndeploy/erptest is to deploy on ErpTest environment\ndeploy/production is to deploy on Production environment\nall commits in both deploy/erptest and deploy/production are synced from Release branch by using git command git reset --hard Release-<YYYYMMDD>","snapshot-branches#Snapshot branches":"All the branches such as: RPGlobal, RPServiceGate, RPWebMVC and RPErpApp are Snapshot branches.\nSnapshot branches includes the current version of the previous release.\nSnapshot branches is used for backup if there's big impact on the current release which cannot rollback.\nHere is the diagram describings how the branches work.","release-cycle#Release Cycle":"This section is to show WHO do WHAT. There're 3 basic roles in this release cycle\nLead or Release Manager\nDeveloper\nTester","phase-1-start-new-release#Phase 1: Start new release":"THINGS TO DO\nDetermine the Scope and the Due Date of the release.\nPrepare the Release branch.\nCreate a new Release branch is based on Test branch with name convention Release-<YYYYMMDD> for all repositories: RPGlobal, RPServiceGate, RPWebMVC, and RPErpApp","phase-2-development#Phase 2: Development":"THINGS TO DO\nDevelop new features, provide bugfixes or hotfixes (if any).\nVerify the changes\nThe hotfixes can be deployed at Phase 3: Release or Phase 4: Hotfix Release. It depends on the impact of the bugs.\nThe list of open pull requests\nReview and Merge Pull Requests of team members into Test branch. Note that Use Squash and Merge to combine multiple commits into single commit, it helps for cherry-pick a lot\ncherry-pick merged commits into Release branch\ncherry-pick hotfix commits into Deploy branch from Release branch (If any)\nSync all commits from Release branch into deploy/erptest (if needed)\nCreate a new branch from Test branch\nWhen the features, bugfixes or hotfixes are DONE, create a Pull Request to Test branch for review\nNotify Lead for review.\nHow to create Pull RequestStep 1Step 2Step 3: If your pull request is for hotfix, add hotfix label. Otherwise, leave it blank.\nDeploy the Test branch on Cloud everyday\nVerify all the changes from Developers for the release.\nCreate bug ticket (If any)","phase-3-release#Phase 3: Release":"THINGS TO DO\nDeploy on ErpTest and Production\nEnsure all changes have been PASSED all tests.\nThis phase is to release (deploy) all changes from the Phase 2: Development\nReview all commits for the release.\nSync all commits from Release branch into deploy/erptest and deploy/production branch.\nCreate build and deploy on ErpTest and Production","phase-4-hotfix-release-optional#Phase 4: Hotfix Release (Optional)":"THINGS TO DO\nRe-deploy the hotfixes on ErpTest and Production\nThis phase does NOT depend on other phases and can be released whenever necessary.\nThis phase only happens if critical bugs found on Production needed to fix ASAP.\nThis phase only includes DEPLOYMENT not DEVELOPMENT works. All hotfixes have been already done at Phase 2: Development\nSync hotfix commits from Release branch into deploy/erptest and deploy/production branch.\nCreate build and re-deploy on ErpTest and Production","phase-5-close-the-release#Phase 5: Close the release":"The quality of the release is good and stable enough to move the next release.THINGS TO DO\nCreate a snapshot for the release.\nSync all Release branches with RPGlobal, RPServiceGate, RPWebMVC and RPErpApp branch"}},"/test-document/demo-training-document":{"title":"Demo Training Document","data":{"":"akjdfajs;flajflkdjfslkdjfdl;ajf","gioi-thieu-mot-chut-nhe#Gioi thieu mot chut nhe":"alsjdflajslkfjasldjfalsjfdkCtrl + J"}},"/test-document":{"title":"Overview","data":{"":"Trong test-document nay minh se de cap den nhung van de sau\nDemo Training Document: Day la DOCUMENT dung de training demo"}},"/development-guide/mobile-app-development":{"title":"Mobile App Development","data":{"":"This project is developed on top of React Native. In this article, you will have a chance to get familiar with the project on the following points\nHow to install\nHow the project structure looks like\nHow to implement a new screen\nHow to configure the integration with 3rd parties","installation#Installation":"You can find the installation guide of this mobile app project at https://github.com/rp-erp/RPErpApp","how-the-project-structure-looks-like#How the project structure looks like":"Overall, we do not follow any common pattern in the world. We organize the project under module hierachy. All modules are stored in src/app/module folder. It can contains sub module itself. Each sub module contains components, hooks, and screens folder. Here is an example\nsrc/app/module/sales-marketing\n├── rfq-approval\n│   ├── components\n│   │   ├── rfq-pending-approval-list.component.tsx\n│   │   └── rfq-signing-document.component.tsx\n│   ├── hooks\n│   │   ├── useGetRFQPendingApprovalList.tsx\n│   │   ├── useGetRFQSigningDocument.tsx\n│   │   ├── useRFQApprove.tsx\n│   │   └── useRFQReject.tsx\n│   └── screens\n│       ├── rfq-pending-approval-list.screen.tsx\n│       └── rfq-signing-document.screen.tsx\n└── rfq-documents\n    ├── components\n    │   ├── rfq-document-list.component.tsx\n    │   └── rfq-document-viewer.component.tsx\n    ├── hooks\n    │   ├── useGetRFQDocuments.tsx\n    │   └── useUploadRFQDocument.tsx\n    └── screens\n        ├── rfq-document-list.screen.tsx\n        └── rfq-document-viewer.screen.tsx\nThe tree diagram illustrates the folder structure of Sales & Marketing module. This module includes some sub modules such as RFQ Approval and RFQ Documents. Each sub module contains components, hooks and screens folder.","how-to-implement-a-new-screen#How to implement a new screen":"","component-and-screen-relationship#Component and Screen Relationship":"Each component contains a collection of pure react components that are used in an associated screen. For example, the screen RFQPendingApprovalListScreen defined in rfq-pending-approval-list.screen.tsx file looks like\nexport const RFQPendingApprovalListScreen = withRPLayout(\n  (props: RPProps) => {\n    return (\n      <View>\n        <RFQPendingApprovalList />\n      </View>\n    );\n  },\n  {\n    Title: 'RFQ Pending Approval',\n  }\n);\nObviously, there's a file call rfq-pending-approval-list.component.tsx file that is associated with rfq-pending-approval-list.screen.tsx file. In component file, we have a pure component named RFQPendingApprovalList, we call this component is main component.\nexport const RFQPendingApprovalList = (props: PendingApprovalListProps) => {\n  return (\n    <>\n      <RPSearchBar onChange={handleSearch} />\n      <FlatList\n        showsVerticalScrollIndicator={false}\n        data={getData()}\n        renderItem={({ item }) => (\n          <RFQPendingApprovalItem\n            item={item}\n            onDetail={onDetail}\n            allowQuickSign={() => true}\n            onQuickSign={onQuickSign}\n          />\n        )}\n        keyExtractor={(item) => item.id}\n        refreshControl={<RefreshControl refreshing={refreshing} onRefresh={onRefresh} />}\n      />\n    </>\n  );\n};\nAs can be seen that the RFQPendingApprovalItem is used in RFQPendingApprovalList component. It is allowed to define in rfq-pending-approval-list.component.tsx as well. It means that you can create multiple components that support the main component.\nexport const RFQPendingApprovalList = (props: PendingApprovalListProps) => { \n  ...//implementation here\n}\nconst RFQPendingApprovalItem = React.memo((props: RFQPendingApprovalProps) => {\n  const { theme } = useTheme();\n  const { item, allowQuickSign, onDetail, onQuickSign } = props;\n  const hasQuickSign = () => allowQuickSign && onQuickSign;\n  return (\n    <TouchableOpacity onPress={() => onDetail(item)}>\n      <ListItem bottomDivider containerStyle={{ paddingVertical: 0, minHeight: 50 }}>\n        <Text>Quote #</Text>\n        <ListItem.Content>\n          <ListItem.Title>\n            <Text bold>{item.quoteNumber}</Text>\n          </ListItem.Title>\n        </ListItem.Content>\n        <View\n          style={{\n            flexDirection: 'row',\n            columnGap: theme.breakpoint.md,\n          }}\n        >\n          {\n            //To show quick sign button\n            hasQuickSign() && (\n              <TouchableOpacity onPress={() => onQuickSign!(item)}>\n                <View\n                  style={{\n                    flex: 1,\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    padding: theme.breakpoint.xs,\n                  }}\n                >\n                  <Icon\n                    type=\"font-awesome-5\"\n                    name=\"signature\"\n                    size={theme.icon.size.sm}\n                    color={theme.colors.primary}\n                  />\n                  <Text size=\"sm\">Sign</Text>\n                </View>\n              </TouchableOpacity>\n            )\n          }\n        </View>\n        <ListItem.Chevron size={theme.font.size.lg} />\n      </ListItem>\n    </TouchableOpacity>\n  );\n});","hooks#Hooks":"Hooks is a component that serve a common logic among the screen. Consider this example, we usually fetch data then set it into React State inside an react component, From now, instead doing that, we package all fetch logic and set state into a hook then use it in a react component. Let's see this example\nexport const RFQDocumentListScreen = withRPLayout((props: RPProps) => {\n  const { quoteNumber } = props.route.params;\n  const RPStyle = useRPStyles();\n  const { isLoading, data: documents } = useGetRFQDocuments(quoteNumber);\n  // On Press Sign button\n  const navigateToDocumentViewer = (document: RFQDocumentDTO) => {\n    props.navigation.navigate(ScreenNavigator.RFQDocumentViewer, {\n      document,\n    });\n  };\n  return (\n    <View style={RPStyle.moduleView}>\n      <RFQDocumentList\n        isLoading={isLoading}\n        data={documents || []}\n        onDetail={navigateToDocumentViewer}\n      />\n    </View>\n  );\n});\nimport { useQuery } from '@tanstack/react-query';\nimport { RFQServices } from '../../../../services/sales-marketing/rfq.service';\nexport const useGetRFQDocuments = (quoteNumber: number) => {\n  return useQuery({\n    queryKey: [useGetRFQDocuments.name, quoteNumber],\n    queryFn: async () => {\n      return RFQServices.getRFQDocuments(quoteNumber);\n    },\n  });\n};\nIn this example, The useGetRFQDocuments hook is used to fetch the RFQ documents associated with the given quoteNumber. The isLoading and data (renamed to documents) are destructured from the result of the hook. If the \"Sign\" button is pressed on a document in the list, the navigateToDocumentViewer function is called, which navigates to the RFQDocumentViewer screen with the selected document.\nuseGetRFQDocuments is a custom hook that uses the useQuery hook from the react-query library to fetch RFQ documents associated with a given quoteNumber. The queryKey is an array that uniquely identifies this query and the quoteNumber it's associated with. The queryFn is an asynchronous function that calls RFQServices.getRFQDocuments(quoteNumber) to fetch the RFQ documents. The RFQServices is presumably a service module that handles API calls related to RFQs.React-Query documentation: https://tanstack.com/query/v3/docs/framework/react/quick-start","how-to-define-a-new-navigation#How to define a new navigation":"We use react-navigation for the Navigation, you can find the navigation documentation at https://reactnavigation.org/docs/getting-startedWith the support of navigation, we can navigate or redirect or switch from a screen to another screen easily. Apprarently, you can find navigation defination at src/app/navigator. The tree below shows all the exising navigation\nsrc/app/navigator\n├── AppNavigator.tsx\n├── MainNavigator.tsx\n├── RootNavigator.tsx\n├── drawer-screen\n│   ├── index.tsx\n│   ├── it.drawer.tsx\n│   ├── packaging.drawer.tsx\n│   ├── phy-inv.drawer.tsx\n│   ├── prod-status.drawer.tsx\n│   ├── purchasing.drawer.tsx\n│   └── sale-marketing.drawer.tsx\n└── stack-screen\n    ├── index.tsx\n    ├── it.stack.tsx\n    ├── purchasing.stack.tsx\n    ├── sale-marketing.stack.tsx\n    └── user.stack.tsx\nAppNavigator.tsx is usually the main navigation file in a React Native application. It's where you define the different screens of your app and how to navigate between them. This file typically uses a navigation library like React Navigation. Here's a basic example of what an AppNavigator.tsx file might look like:\nimport React from 'react';\nimport { createStackNavigator } from '@react-navigation/stack';\nimport HomeScreen from './screens/HomeScreen';\nimport DetailsScreen from './screens/DetailsScreen';\nconst Stack = createStackNavigator();\nfunction AppNavigator() {\n  return (\n    <Stack.Navigator initialRouteName=\"Home\">\n      <Stack.Screen name=\"Home\" component={HomeScreen} />\n      <Stack.Screen name=\"Details\" component={DetailsScreen} />\n    </Stack.Navigator>\n  );\n}\nexport default AppNavigator;\nIn this example, AppNavigator is a component that uses a stack navigator from React Navigation to define two screens: HomeScreen and DetailsScreen. The initialRouteName prop is used to specify which screen should be shown first when the app starts.Please note that this is just a basic example. Your AppNavigator.tsx file might be different based on your app's requirements and the navigation library you're usingIn terms of implementation, please refer the navigation document and review the existing code to understand how it work.","how-to-configure-the-integration-with-3rd-parties#How to configure the integration with 3rd parties":"There are 2 api approviders as 3rd parties using in this mobile app\nService Gate APIs: is to contain the main business implementation of RP-ERP project.\nTooling Service APIs: is to contain the message queues and lightweight calculator to reduce the load from Service Gate APIs.\nHere is an example of RFQ Approval Integration.\nThis diagram describes a sequence where the mobile app sends a request to the Server Gate API, receives a response, allows the user to sign a document, and updates the Server Gate API with the signed document. Then, the mobile app sends the signed document (as a base64 image) to the Tooling Service API, which converts the image to a PDF and exports it in both jpg and pdf formats on Azure.\nTo configure Service Gate API connection, go to src/app/common/utilities.tsx\nTo configure Tooling Service API connection, go to src/app/common/api-clients/rp-tooling/config.ts\nNote: For VN Team, we are using Cloud and Local.","checklist-for-development#Checklist For Development":"Create a module folder\nCreate a sub module folder\nCreate components, screen and hooks in the sub module folder\nCreate component file and screen file\nCreate hooks files\nCreate services (if any)"}}}