{"/development-guide":{"title":"Overview","data":{}},"/howto/create-ssl-for-viettel-cloud":{"title":"Create SSL for Viettel Cloud","data":{"":"Create new account at ZeroSSL . With new account will be Free 3 months\nIn Dashboard, click New Certificate (Image 1)\nEnter required information (Domains: 27.71.232.40; Validity: 90-Day Certificate; Finalize Your Order: Free) => click Next Step\nVerification Method for 27.71.232.40 choose HTTP File Upload and Download Auth File. After download complete, click Next Step  (Image 2)\n5.Add file downloaded to Viettel cloud IIS  with URL in Image 2\n6. Click Verify Domain (Image 3)\nDownload Certificate as zip file (Image 4) and click Next Step\nExtract zip file on Viettel Server, open Start Menu, type openssl, open program and browse to extracted folder (Image 5)\nCopy content file create file pfx.txt and run in Open SSL cmd (Image 6)\nEnter password, this password use to import certificate into IIS (ex: robinsonpharma), after done, we have certificate.pfx file in extracted folder (Image 7)\nOpen IIS Manager → Server Certificates → Remove old certificate (if any) → Click Import (Image 8)\nUse pfx file create before and password enter at step 10 → click OK (Image 9)\nIn IIS choose each Website and update binding to new certificate (Image 10)"}},"/howto/how-to-install-redis-on-window-server":{"title":"How to install Redis on Windows Server","data":{"":"This article shows the instruction on how to install Redis server on Window Server.Overall, there are two main parts of the installation\nInstall Subsystem Ubuntu\nInstall Redis Stack Server","1-install-subsystem-ubuntu#1. Install Subsystem Ubuntu":"Redis from the 7.x.x version does not support on native window anymore. So we need to install linux subsystem and install Redis on top of it.To begin with, please open POWER SHELL and follow the steps below.Step 1: Download Ubuntu and enable Linux Subsystem mode on Windows (You should not run Ubuntu 20.04 LTS version because there are some recorded issues that have not been fixed on the official MS website, so we will use Ubuntu 18.04 LTS version)\nInvoke-WebRequest -Uri https://aka.ms/wsl-ubuntu-1804 -OutFile Ubuntu.zip -UseBasicParsing\nStep 2: Unzip the Ubuntu file downloaded in the step #1\nExpand-Archive ./Ubuntu.zip ./Ubuntu\nStep 3: Set environment variables\n$userenv = [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\")\n[System.Environment]::SetEnvironmentVariable(\"PATH\", $userenv + $(Get-Location).Path + \"\\Ubuntu\", \"User\")\nStep 4: Install WSL, Enter \"Y\" to restart the machine.\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux\nStep 5: Change directory to Ubuntu folder and execute ubuntu1804.exe file\ncd Ubuntu\n.\\ubuntu1804.exe\nStep 6: Set up your root user. Note: it should be your window machine username. In sta\nsudo passwd <your_window_user>\nNew password: <pass_word>\nRetype new password: <pass_word>\nStep 7\nsu <your_window_user>\n<Enter the password>\nStep 8: Update package repository\nsudo apt-get update\nsudo apt-get upgrade","2-install-redis-stack-server#2. Install Redis Stack Server":"First, access to linux terminal\nwsl\nThen, follow the steps below.Step 1\ncurl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg\nStep 2\nsudo chmod 644 /usr/share/keyrings/redis-archive-keyring.gpg\nStep 3\nsudo apt-get update\nStep 4\necho \"deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/redis.list\nStep 5\nsudo apt-get install redis-stack-server\nStep 6\nmkdir redis_db_data\nStep 6: Create redis.conf at the same folder level with this contentNote: put your redis password on <redis_password>\nbind 0.0.0.0\nport 6380\nrequirepass <redis_password>\nsave 60 1000\nappendonly yes\ndir /redis_db_data\nStep 7: Allow Redis portopen POWER SHELL and execute the command below\nNew-NetFirewallRule -DisplayName \"Allow Redis Port 6380\" -Direction Inbound -LocalPort 6380 -Protocol TCP -Action Allow"}},"/howto/install-ssh-server-on-window":{"title":"How to Install SSH Server on Windows","data":{"install-ssh-server#Install SSH Server":"To set up SSH access to your Windows server, you can use the built-in OpenSSH Server. Here's a step-by-step guide:\nInstall OpenSSH Server: Open PowerShell as Administrator and run the following command:\nAdd-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0\nStart the service: Once installed, start the SSH server service by running:\nStart-Service sshd\nSet the service to start automatically: To ensure the SSH server is automatically started after a reboot, run:\nSet-Service -Name sshd -StartupType 'Automatic'\nConfirm the Firewall rule is configured: It should be created automatically by the setup. In case it's not, run:\nNew-NetFirewallRule -Name sshd -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22\nCheck the installation: You can check that the installation was successful by running:\nGet-WindowsCapability -Online | ? Name -like 'OpenSSH*'\nCreate an SSH key pair: On your local machine, use ssh-keygen to create an SSH key pair. If you're on Linux or macOS, you can use the following command:\nssh-keygen\nSet permission\ncd ~\nmkdir .ssh\nnotepad.exe .ssh\\authorized_keys\nAdd content for authorized_keys file\nicacls .ssh /inheritance:r\nicacls .ssh /grant \"your-username:(F)\"\nicacls .ssh\\authorized_keys /inheritance:r\nicacls .ssh\\authorized_keys /grant \"your-username:(F)\"\nOpen config file at C:\\\\ProgramData\\ssh\\sshd_config and remove the # at the beginning of the line to uncomment it, and change 22 to your desired port number. For example, to change the SSH port to 2422\nPort 2422\nOpen Port 2422\nNew-NetFirewallRule -DisplayName \"Open Port 2422\" -Direction Inbound -LocalPort 2422 -Protocol TCP -Action Allow\nRestart SSH server to take effect\nRestart-Service sshd\nGet-Service sshd","setup-ssh-user#Setup SSH User":"Create a new user\nYou can create a new user with the following command in PowerShell, replacing username and password with the username and password you want to use\nNew-LocalUser -Name \"username\" -Password (ConvertTo-SecureString -AsPlainText \"password\" -Force)\nAdd a user to the Administrators group\nTo add a user to the Administrators group on a Windows Server using PowerShell, you can use the Add-LocalGroupMember cmdlet. Here's how you can do it\nAdd-LocalGroupMember -Group \"Administrators\" -Member \"username\"\nAllow the user to log in through SSH\nBy default, only users in the Administrators group can log in through SSH. If the user is not in the Administrators group, you'll need to add them to the sshd_config file. You can do this by opening the file (usually located at C:\\ProgramData\\ssh\\sshd_config) in a text editor and adding the following line, replacing username with the username you used in the previous steps:\nAllowUsers username\nAfter making these changes, you'll need to restart the OpenSSH Server service for the changes to take effect. You can do this with the following command in PowerShell\nRestart-Service sshd"}},"/":{"title":"RP-ERP Knowledge Base","data":{"":"Welcome to the RP-ERP Knowledge Base, your one-stop destination for mastering both technical intricacies and business processes in the world of Enterprise Resource Planning. Dive into a curated collection of technical documentation for seamless integration, and explore strategic insights to elevate your understanding of RP-ERP's impact on operational efficiency. Whether you're a tech enthusiast or a business leader, find the expertise you need to excel in resource planning and enterprise excellence."}},"/process/release-management":{"title":"Git Strategies & Release Management","data":{"overview#Overview":"The release cycle has 5 phases\nPhase 1: Start new release\nPhase 2: Develop\nPhase 3: Release\nPhase 4: Hotfix release (Optional)\nPhase 5: Close the release","branches#Branches":"","default-branch#Default branch":"All branches have suffix Test in name are default branches: RPGlobal-Test, RPServiceGate-Test, RPWebMVC-Test, AppTest\nTest branches have the latest commits including New features, Bugfixes and Hotfixes\nTest branches are the base branches of Developers on their daily work. It means that all commits MUST BE merged into Test branches first.","release-branch#Release branch":"Release branch is created at Phase 1: Start new release and based on Test branch.\nRelease branch's name has the following convention Release-<YYYYMMDD>. For example, the release name Release-20231121 indicating that all commits in this branch are releasing on 21 November, 2023\nAll commits are ready to push into Release branch must come from Test branch and pushed by using cherry-pick instead of merge","deploy-branches#Deploy branches":"Deploy branches will be used for CI/CD pipeline in the future\nThere're 2 deploy branches: deploy/erptest and deploy/production\ndeploy/erptest is to deploy on ErpTest environment\ndeploy/production is to deploy on Production environment\nall commits in both deploy/erptest and deploy/production are synced from Release branch by using git command git reset --hard Release-<YYYYMMDD>","snapshot-branches#Snapshot branches":"All the branches such as: RPGlobal, RPServiceGate, RPWebMVC and RPErpApp are Snapshot branches.\nSnapshot branches includes the current version of the previous release.\nSnapshot branches is used for backup if there's big impact on the current release which cannot rollback.\nHere is the diagram describings how the branches work.","release-cycle#Release Cycle":"This section is to show WHO do WHAT. There're 3 basic roles in this release cycle\nLead or Release Manager\nDeveloper\nTester","phase-1-start-new-release#Phase 1: Start new release":"THINGS TO DO\nDetermine the Scope and the Due Date of the release.\nPrepare the Release branch.\nCreate a new Release branch is based on Test branch with name convention Release-<YYYYMMDD> for all repositories: RPGlobal, RPServiceGate, RPWebMVC, and RPErpApp","phase-2-development#Phase 2: Development":"THINGS TO DO\nDevelop new features, provide bugfixes or hotfixes (if any).\nVerify the changes\nThe hotfixes can be deployed at Phase 3: Release or Phase 4: Hotfix Release. It depends on the impact of the bugs.\nThe list of open pull requests\nReview and Merge Pull Requests of team members into Test branch. Note that Use Squash and Merge to combine multiple commits into single commit, it helps for cherry-pick a lot\ncherry-pick merged commits into Release branch\ncherry-pick hotfix commits into Deploy branch from Release branch (If any)\nSync all commits from Release branch into deploy/erptest (if needed)\nCreate a new branch from Test branch\nWhen the features, bugfixes or hotfixes are DONE, create a Pull Request to Test branch for review\nNotify Lead for review.\nHow to create Pull RequestStep 1Step 2Step 3: If your pull request is for hotfix, add hotfix label. Otherwise, leave it blank.\nDeploy the Test branch on Cloud everyday\nVerify all the changes from Developers for the release.\nCreate bug ticket (If any)","phase-3-release#Phase 3: Release":"THINGS TO DO\nDeploy on ErpTest and Production\nEnsure all changes have been PASSED all tests.\nThis phase is to release (deploy) all changes from the Phase 2: Development\nReview all commits for the release.\nSync all commits from Release branch into deploy/erptest and deploy/production branch.\nCreate build and deploy on ErpTest and Production","phase-4-hotfix-release-optional#Phase 4: Hotfix Release (Optional)":"THINGS TO DO\nRe-deploy the hotfixes on ErpTest and Production\nThis phase does NOT depend on other phases and can be released whenever necessary.\nThis phase only happens if critical bugs found on Production needed to fix ASAP.\nThis phase only includes DEPLOYMENT not DEVELOPMENT works. All hotfixes have been already done at Phase 2: Development\nSync hotfix commits from Release branch into deploy/erptest and deploy/production branch.\nCreate build and re-deploy on ErpTest and Production","phase-5-close-the-release#Phase 5: Close the release":"The quality of the release is good and stable enough to move the next release.THINGS TO DO\nCreate a snapshot for the release.\nSync all Release branches with RPGlobal, RPServiceGate, RPWebMVC and RPErpApp branch"}},"/development-guide/mobile-app-development":{"title":"Mobile App Development","data":{"":"This project is developed on top of React Native. In this article, you will have a chance to get familiar with the project on the following points\nHow to install\nHow the project structure looks like\nHow to implement a new screen\nHow to configure the integration with 3rd parties","installation#Installation":"You can find the installation guide of this mobile app project at https://github.com/rp-erp/RPErpApp","how-the-project-structure-looks-like#How the project structure looks like":"Overall, we do not follow any common pattern in the world. We organize the project under module hierachy. All modules are stored in src/app/module folder. It can contains sub module itself. Each sub module contains components, hooks, and screens folder. Here is an example\nsrc/app/module/sales-marketing\n├── rfq-approval\n│   ├── components\n│   │   ├── rfq-pending-approval-list.component.tsx\n│   │   └── rfq-signing-document.component.tsx\n│   ├── hooks\n│   │   ├── useGetRFQPendingApprovalList.tsx\n│   │   ├── useGetRFQSigningDocument.tsx\n│   │   ├── useRFQApprove.tsx\n│   │   └── useRFQReject.tsx\n│   └── screens\n│       ├── rfq-pending-approval-list.screen.tsx\n│       └── rfq-signing-document.screen.tsx\n└── rfq-documents\n    ├── components\n    │   ├── rfq-document-list.component.tsx\n    │   └── rfq-document-viewer.component.tsx\n    ├── hooks\n    │   ├── useGetRFQDocuments.tsx\n    │   └── useUploadRFQDocument.tsx\n    └── screens\n        ├── rfq-document-list.screen.tsx\n        └── rfq-document-viewer.screen.tsx\nThe tree diagram illustrates the folder structure of Sales & Marketing module. This module includes some sub modules such as RFQ Approval and RFQ Documents. Each sub module contains components, hooks and screens folder.","how-to-implement-a-new-screen#How to implement a new screen":"","component-and-screen-relationship#Component and Screen Relationship":"Each component contains a collection of pure react components that are used in an associated screen. For example, the screen RFQPendingApprovalListScreen defined in rfq-pending-approval-list.screen.tsx file looks like\nexport const RFQPendingApprovalListScreen = withRPLayout(\n  (props: RPProps) => {\n    return (\n      <View>\n        <RFQPendingApprovalList />\n      </View>\n    );\n  },\n  {\n    Title: 'RFQ Pending Approval',\n  }\n);\nObviously, there's a file call rfq-pending-approval-list.component.tsx file that is associated with rfq-pending-approval-list.screen.tsx file. In component file, we have a pure component named RFQPendingApprovalList, we call this component is main component.\nexport const RFQPendingApprovalList = (props: PendingApprovalListProps) => {\n  return (\n    <>\n      <RPSearchBar onChange={handleSearch} />\n      <FlatList\n        showsVerticalScrollIndicator={false}\n        data={getData()}\n        renderItem={({ item }) => (\n          <RFQPendingApprovalItem\n            item={item}\n            onDetail={onDetail}\n            allowQuickSign={() => true}\n            onQuickSign={onQuickSign}\n          />\n        )}\n        keyExtractor={(item) => item.id}\n        refreshControl={<RefreshControl refreshing={refreshing} onRefresh={onRefresh} />}\n      />\n    </>\n  );\n};\nAs can be seen that the RFQPendingApprovalItem is used in RFQPendingApprovalList component. It is allowed to define in rfq-pending-approval-list.component.tsx as well. It means that you can create multiple components that support the main component.\nexport const RFQPendingApprovalList = (props: PendingApprovalListProps) => { \n  ...//implementation here\n}\nconst RFQPendingApprovalItem = React.memo((props: RFQPendingApprovalProps) => {\n  const { theme } = useTheme();\n  const { item, allowQuickSign, onDetail, onQuickSign } = props;\n  const hasQuickSign = () => allowQuickSign && onQuickSign;\n  return (\n    <TouchableOpacity onPress={() => onDetail(item)}>\n      <ListItem bottomDivider containerStyle={{ paddingVertical: 0, minHeight: 50 }}>\n        <Text>Quote #</Text>\n        <ListItem.Content>\n          <ListItem.Title>\n            <Text bold>{item.quoteNumber}</Text>\n          </ListItem.Title>\n        </ListItem.Content>\n        <View\n          style={{\n            flexDirection: 'row',\n            columnGap: theme.breakpoint.md,\n          }}\n        >\n          {\n            //To show quick sign button\n            hasQuickSign() && (\n              <TouchableOpacity onPress={() => onQuickSign!(item)}>\n                <View\n                  style={{\n                    flex: 1,\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    padding: theme.breakpoint.xs,\n                  }}\n                >\n                  <Icon\n                    type=\"font-awesome-5\"\n                    name=\"signature\"\n                    size={theme.icon.size.sm}\n                    color={theme.colors.primary}\n                  />\n                  <Text size=\"sm\">Sign</Text>\n                </View>\n              </TouchableOpacity>\n            )\n          }\n        </View>\n        <ListItem.Chevron size={theme.font.size.lg} />\n      </ListItem>\n    </TouchableOpacity>\n  );\n});","how-to-define-a-new-navigation#How to define a new navigation":"We use react-navigation for the Navigation, you can find the navigation documentation at https://reactnavigation.org/docs/getting-startedWith the support of navigation, we can navigate or redirect or switch from a screen to another screen easily. Apprarently, you can find navigation defination at src/app/navigator. The tree below shows all the exising navigation\nsrc/app/navigator\n├── AppNavigator.tsx\n├── MainNavigator.tsx\n├── RootNavigator.tsx\n├── drawer-screen\n│   ├── index.tsx\n│   ├── it.drawer.tsx\n│   ├── packaging.drawer.tsx\n│   ├── phy-inv.drawer.tsx\n│   ├── prod-status.drawer.tsx\n│   ├── purchasing.drawer.tsx\n│   └── sale-marketing.drawer.tsx\n└── stack-screen\n    ├── index.tsx\n    ├── it.stack.tsx\n    ├── purchasing.stack.tsx\n    ├── sale-marketing.stack.tsx\n    └── user.stack.tsx\nAppNavigator.tsx is usually the main navigation file in a React Native application. It's where you define the different screens of your app and how to navigate between them. This file typically uses a navigation library like React Navigation. Here's a basic example of what an AppNavigator.tsx file might look like:\nimport React from 'react';\nimport { createStackNavigator } from '@react-navigation/stack';\nimport HomeScreen from './screens/HomeScreen';\nimport DetailsScreen from './screens/DetailsScreen';\nconst Stack = createStackNavigator();\nfunction AppNavigator() {\n  return (\n    <Stack.Navigator initialRouteName=\"Home\">\n      <Stack.Screen name=\"Home\" component={HomeScreen} />\n      <Stack.Screen name=\"Details\" component={DetailsScreen} />\n    </Stack.Navigator>\n  );\n}\nexport default AppNavigator;\nIn this example, AppNavigator is a component that uses a stack navigator from React Navigation to define two screens: HomeScreen and DetailsScreen. The initialRouteName prop is used to specify which screen should be shown first when the app starts.Please note that this is just a basic example. Your AppNavigator.tsx file might be different based on your app's requirements and the navigation library you're usingIn terms of implementation, please refer the navigation document and review the existing code to understand how it work.","how-to-configure-the-integration-with-3rd-parties#How to configure the integration with 3rd parties":"There are 2 api approviders as 3rd parties using in this mobile app\nService Gate APIs: is to contain the main business implementation of RP-ERP project.\nTooling Service APIs: is to contain the message queues and lightweight calculator to reduce the load from Service Gate APIs.\nHere is an example of RFQ Approval Integration.\nThis diagram describes a sequence where the mobile app sends a request to the Server Gate API, receives a response, allows the user to sign a document, and updates the Server Gate API with the signed document. Then, the mobile app sends the signed document (as a base64 image) to the Tooling Service API, which converts the image to a PDF and exports it in both jpg and pdf formats on Azure.\nTo configure Service Gate API connection, go to src/app/common/utilities.tsx\nTo configure Tooling Service API connection, go to src/app/common/api-clients/rp-tooling/config.ts\nNote: For VN Team, we are using Cloud and Local."}}}